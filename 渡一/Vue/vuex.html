<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 

        vuex

        Vue.use(Vuex)

        const store = new Vuex.Store({
            state:{

            }
        })

        new Vue({
            store
        })

        State

        单一状态树,使用一个对象,就包含了全部的应用层级状态

        在Vuex通过 store选项,提供了一种机制,将状态从跟组件 注入到每一个子组件中(调用Vue.use(Vuex))
         
        通过在根实例注册 store选项,该store实例会注入到跟组件下的所有组件中,且子组件能通过 this.$store访问


        在页面中使用 store.state 中的属性时为了避免 冗余 可以在 computed中定义计算属性 来动态获取值

        vuex提供了辅助函数 mapState

        import {mapState } from 'vuex'

        computed:{
            ...mapState([])
        }

        当现有data数据与 state中的命名冲突时

        computed:{
            ...mapState({
                storeCount:state => state.count
                storeCount: 'count'
            })
        }

        Vuex_Getter

        store的计算属性 getter的返回值会根据它的依赖被缓存起来,且只有当它的依赖值发生了改变才会被重新计算  

        getter 接收 state作为其第一个参数, getters 作为其第二个参数


        new Vuex.Store({
            state:{
                count:1
            },
            getters:{
                doubleCount(state){
                    return state.count*2
                }
            }
        })
      
        通过属性访问

        Getter会暴露store.getters对象: this.$store.getters.doubleCount

        getter的辅助函数

        ...mapGetters([])


        mutation

        更改 vuex的 store中的状态的唯一的方法是 提交 mutation

        严格模式

        开启严格模式下仅需在创建 store的时候传入 strict

        mutations:{
            changeCount(state){
                state.count++;
            }
        }

        this.$store.commit('changeCount',{num})

        this.$store.commit({
            type:'changeCount',
            num:1
        })
        ...mapMutations()


        使用常量替代事件类型

        在mutation中依旧会有 vue的数据响应问题 

        依旧可以通过 vue.set()

        mutation 必须是同步函数     


        action

        action与mutation类似  不同在于

        action 提交的是 mutation 而不是直接变更状态
        action 可以包含任意异步操作

        action 函数接受一个与 store实例具有相同方法和属性的 context对象,因此你可以调用context.commit提交
        一个mutation

        actions:{
             increment(context){
                return new Promise({

                })
             }
        }

        this.$store.dispatch('')


        module

        modules  

        每个module都有自己的state mutations actions getter

        export default{

        }

        new Vuex.Store({
            modules:{

            }
        })


        只有state会发生模块的改变 变成 传入的module名称下的 一个属性

        获取 state: this.$store.moduleName.xxx
            getter: this.$store.getters.xxx
            mutation:this.$store.commit()
            action:this.$store.dispatch()


        
        命名空间

        可以通过添加 namespaced:true的方式 使其成为带命名空间 的模块

        ...mapState('namespaced',[])


        模块的局部状态

        对于模块内部的mutation 和 getter 接收第一个参数是模块的局部状态对象

        同样对于模块内部的action,局部状态是通过context.state 暴露出来,跟节点状态则为 context.rootState

        对于模块内部的getter,根节点状态会作为第三个参数



        vuex源码部分
     -->
</body>
</html>