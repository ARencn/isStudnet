<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //第一张 概述
        /* 
        ecmaScript  JavaScript NodeJs

        ES3.0   1999
        ES5.0   2009
        ES6.0   2015
        
        
         */


         //第二章 块级绑定

         /* 
            声明变量的问题

            1.允许重复的变量声明:导致数据覆盖
            2.变量提升:怪异的数据访问,闭包问题
            3.全局变量挂载到全局对象,全局对象成员污染的问题


            关键字 let

            let 声明的对象不会挂载全局对象上
            let 声明的变量 不允许在当前作用域内 重复声明

            引入了块级作用域

            使用let 不会有变量提升 实际上也有提升 不过会被提升到 暂时性死区 
            当代码运行到变量声明时 会将其从暂时性死区中移除

            在循环中用let 声明的循环变量 会特殊处理,每次进入循环体都会开启新的作用域 并将循环变量绑定到作用域 
            在循环中使用let 声明的循环变量会在结束后销毁


            const 声明变量

            const 和 let作用相同,区别,必须在声明时赋值,而且不可以重新赋值 

            在开发中尽量使用const
          */
          //字符串和正则表达式
          /* 
            codePointAt() 通过字符串位置得到其码点

            正则新增 flag

            u ,如果增加了 该配置使用码点进行匹配


            更多的字符串API

            includes(content,position):判断字符串中是否包含指定的字符串  第二个参数为从指定位置开始查找

            startsWith(content,position):判断字符串是否以指定的字符串开头
            endsWith(content,position):判断字符串是否以指定的字符串结尾
            repeat():将字符串重复指定的次数返回新字符串


            正则中的粘连标记
            
            新增flag:y 会从 reg.lastIndex位置开始匹配


            模板字符串

            ``

            模板字符串标记

            在模板字符串前加上标记函数

            const text = myFlag`这是一个${a}插值标记${b}函数.`

            myFlag:()=>{
                该函数第一个参数为 ${}分割开的字符串数组 [这是一个,插值标记,函数]
                后面的参数 即为插值中的值 {a}{b}
            }

            const test = String.raw``
            加上 String.raw 标记的模板字符串 表示该字符串内无任何需要转义的内容

*/
        //   函数
           /*   'strict'

            参数默认值对 arguments的影响 只要给函数加上参数默认值,该函数会自动变成 严格模式下的规则
            arguments 与形参脱离

            暂时性死区

            形参和 es6中的 let const 一样,具有作用域,并且根据参数的声明顺序,存在暂时性死区

            test(a=b,b){
                形参不能和变量重名
            }

            剩余参数

            function(...args)
            收集剩余的所有参数

            一个函数仅能出现一个剩余参数
            一个函数如果有剩余参数,剩余参数必须是最后一个参数


            展开运算符   ...

            明确函数的用途

            es6提供了特殊的api,可是使用该api在函数内部判断该函数是否使用new调用

            new.target//表示  如果没有使用new来调用函数,则返回undefined  
            如果使用了new调用函数,则得到的是new 关键字后面的函数本身

            if(new.target === undefined){
                throw new Error('')
            }

            箭头函数
            之前的this
            1.通过对象调用函数,this指向对象
            2.直接调用函数,this指向全局对象
            3.通过new调用函数,this指向新创建的对象
            4.如果通过apply call bind调用函数,this指向指定的数据
            5.dom事件函数,this指向事件源

            箭头函数的this

            箭头函数的函数体中的this,取决于箭头函数声明的位置的this位置


            细节:
            箭头函数中没有自己的this arguments new.target,如果使用了则使用的是外层的this
            箭头函数没有原型
            不能作为构造函数


            应用场景

            临时性使用的函数,并不会调用它
                1.事件处理函数
                2.异步处理函数
                3.其他临时性函数
            2.为了绑定外层this 的函数
            3.数组中的回调函数,保持代码简介

           */
           //对象
           /* 
            
            计算属性名

            [a+b]:'s'


            Objec新增API

            object.is
                用于判断两个对象是否相等 基本上与(===) 是一致的
            object.assign
                合并对象
            将obj2的数据覆盖到obj1,并且对obj1产生改动,然后返回obj1



            Object.getOwnPrototypeNames() 的枚举顺序

            此方法之前就已经存在,只是没有明确要求对属性的顺序如何排序 
            现在排序标准:排序方式如下
            先排数字,并按照升序排序
            再排其他


            setPrototypeOf()
            用于设置某个对象的隐式原型

            Object.setPrototypeOf(obj1,obj2)
            相当于 obj1.__proto__ = obj2

            类:构造函数

            特点

                1.类声明不会被提升,与let const一样,存在暂时性死区
                2.类中的所有代码均按照严格模式执行
                3.类的所有方法都是不可枚举的
                4.类的所有方法内部都无法被当做构造函数使用
                5.类的构造器必须使用new来调用



            可计算的成员名
            getter setter 
            静态成员
            初始化器
            使用static 的字段 是静态的
            装饰器(decorator)


            继承

            使用关键字extends 继承

            子类如果写constructor内必须在constructor 第一行手动调用super() super可作为对象即父类的构造函数
            

            解构

            const { age = 19,sex:gender } = user 

            function ajax({ method = 'get',url='/' }={})
            符号

            符号是es6新增的数据类型,通过 symbol

            symbol
            
            symbol的特点
            1.没有字面量
            2.使用typeof 得到的类型是symbol
            3.每次调用 symbol 函数得到的符号永远不相等,无论符号名是否相同   
            4.符号可以作为对象的属性名存在,这种属性称之为符号属性
            5.符号是不能被枚举的 for in无法枚举出 symbol
            6.Object.getOwnPropertyNames getOwnPropertySymbol
            7.符号不能隐式转换 可以显式转换


            共享符号

            根据符号描述 能够得到同一个符号

            Symbol.for('符号名')  获取共享符号

            知名符号    是一些具有特殊含义的共享符号,通过symbol 的静态属性得到

            symbol.hasInstance 

            该符号用于定义构造函数的静态成员,它将影响 instanceof 的判断

            obj instanceof A

            等效于

            A[symbol.instance](obj)

            Symbol.isConcatSpreadable

            */

            function a (){
                            class Pro{
                    age = 1
                    constructor(age){
                            this.age = age;
                    }
                    get age(){
                        return this._age
                    }
                    set age(number){
                        this._age = number
                    }
                    static width=50;
                    
                }

                class test extends Pro{
                    constructor(){
                        super();
                    }
                }

                
                function s(target ,){

                }
                const a = new Pro(1);
                a.age = 10




            }
  
            // promise

         /* 
         
            1.事件循环

            js 运行的环境被称为 宿主环境

            执行栈:call stack,一个数据结构,用于存放 各种函数的执行环境,每一个函数执行之前,它的相关信息会加入到执行栈,函数调用之前,创建执行环境 ,然后加入到执行栈,函数调用后销毁执行环境

            JS引擎永远执行最顶部

            异步函数:某些函数不会立即执行,需要等到某个时机,到达后才执行,这样的函数被称为异步函数,比如事件处理异步函数,异步函数的执行时机,会被宿主环境控制

            浏览器宿主环境包含五个线程:
                1.js引擎 负责执行执行栈的最顶部代码
                2.GUI线程 负责渲染页面
                3.事件监听线程:负责监听各种事件
                4.计时线程:负责计时
                5.网络线程:负责网络通信

                当上面的线程发生了一些事情,如果该线程发现,这件事情有处理程序,它会将该处理程序加入到一个叫做事件队列的内存,当js引擎发现,执行栈中已经没有任何内容后,会将事件队列中的第一个函数加到执行栈中
                JS引擎对事件队列的取出执行方式,以及宿主环境的配合,称为事件循环

                事件队列在不同的 宿主环境中有所差异,大部分宿主环境会将事件队列进行细分,在浏览器中,事件队列分为两种:
                宏任务(macroTask),计时器结束的回调,事件回调,http回调,绝大部分进入宏队列
                微队列:mutationObserver,promise




                事件和回到函数的缺陷


                1.回调地狱
                2.日志分析需求


                异步处理的模型

                1.异步操作的事情分为两个阶段 unsettled 和 settled

                unsettled:未决阶段,表示事情还在进行前期处理,并没有发生通向结果的那件事
                settled:已决阶段,事情已经有了结果,不管这个结果是好是坏,整件事情无法逆转


                事情总是从未决阶段发展到已决阶段,并且未决阶段拥有控制何时通向已决阶段的能力


                2.事情分为三种状态 : pending resolved rejected

                pending:挂起,处于未决阶段,则表示这件事还在挂起,(最终的结果还没有出来)
                resolved:已处理,已决阶段的一种状态,表示整件事情,已经出现了结果,并是一个可以按照正常逻辑处理下去的,
                rejected:已拒绝,已决阶段的一种状态,表示整件事情已经出现结果,并是一个无法按照正常逻辑进行下去的结果,通常用于表示有一个错误


                3.当事情到达已决阶段后,通常需要进行后续的处理,不同的已决状态,决定了不同的后续处理

                resolved状态,这是一个正常的已决状态,后续处理表示为 tenable
                rejected状态,这是一个非正常的已决状态,后续处理表示为,catchable


                整件事被称之为 promise


                未决阶段的  处理函数是同步的,会立即执行
                thenable和catchable 函数是异步的,就算是立即执行,也会加入到事件队列中等待执行,并且加入的是microTaskQueue



                promise 串联

                当后续的处理需要之前的promise 处理结果时,需要promise串联
 
                promise对象无论是 then  还是catch 都是有返回值的,返回的是一个全新的promise 它的状态满足下面规则

                1.如果当前promise 是挂起状态,得到新的promise是挂起状态
                2.如果当前promise 是 已决状态,会运行相应的后续处理函数,并将返回值运用到新的promise中
                3.



                原型成员

                then
                catch
                finally


                静态成员 

                pro =  Promise.resolve(1)


                p = new Promise()
                pro =Promise.resolve(p)

                pro === p  // true 


                all

                race
          */


          //promise 实现

       


          //fetch api

          /**
           * 
           * 
           

           XMLHttpRequest的问题

           1.所有的功能全部集中在同一个对象上,容易书写出混乱不易维护的代码
           2.采用传统的事件驱动模式,无法适配新的 promise api

           fetch api的特点

           1.并非取代ajax 而是对 ajax传统api的改进
           2.精细的功能分割:头部信息,请求信息,响应信息,等均分布到,不同的对象,更利于处理各种复杂的ajax 情景


            fetch api特点

            1.并非取代ajax,而是对ajax传统api取代
            2.精细的功能分割,
            3.使用 promise api更利于异步代码的书写
            4.fetch api并非es6内容,属于h5 新增api
            5.需要掌握网络通信知识



            基础使用:


                参数:
                1.必填,String 请求地址
                2.选填,对象,请求配置

                请求配置对象:
                fetch(url,{
                    method:'psot',
                    headers:{
                        "Content-type":"application/json",

                    },
                    body:{

                    },
                    mode:"" cors:默认值会配置该值,会在请求头中加入,origin和referer; no-cors:不会加入 origin 和 referer; same-origin :指示请求必须在同一个域中发生,如果请求其他域,则报错
                    credentials:如何携带凭据(cookie)
                        omit:默认值,不携带cookie
                        same-origin:请求同源时携带cookie
                        include:请求任何地址都携带cookie
                    cache:配置缓存模式
                        default:表示请求前检查下http的缓存
                        no-store 表示 fetch请求将完全忽略缓存,然后不更新缓存
                        reload:表示先忽略缓存,之后再主动更新缓存
                        force-cache:表示fetch请求不顾一切的依赖缓存,即使缓存过期,依旧从缓存读取,除非没有任何缓存 那么会发送请求
                        only-if-cached:只读取缓存,没有缓存就报错
                })

                返回值:
                fetch 函数返回一个 promise 对象

                当收到服务器的返回结果后,promise进入 resolved状态,状态数据未 response对象
                当网络请求发生错误(或其他导致无法完成交互的错误) 时,promise进入rejected状态 状态数据为错误信息

                response对象:
                ok:boolean当响应消息码在200-299之间,为true,其他为false
                status.:number 响应的状态码
                text():用于处理文本格式的ajax 响应,它从响应中获取文本流,将其读完,然后返回一个被解决为string对象的promise
                json()



                request对象

                除了使用基本的fetch方法,還可以创建 一个request对象来完成请求

                fetch(new Request(url,{}))

                如果通过request 发送请求,尽量每次请求都创建新的request对象

                request.clone()


                response对象

                headers 对象

                has(key) 检查是否存在指定 key
                get(key)
                set(key,value)
                append
                keys:得到可 迭代
                


                文件上传:
                1.客户端将文件数据发送给服务器
                2.服务器保存上传的文件数据到服务器端
                3.服务器响应给客户端一个文件访问地址
                

                使用 FormData 构建请求体
                multiple 
                function upload(){
                    input.files
                    const formData = new FormData();
                    formData.append("imgflie",input.files[0])

                    resp = await fetch(url,{
                        method:post,
                        // headers:{
                        //     "content-type":"multipart/form-data"
                        // },
                        body:formData //会自动修改请求头
                    })
                }
           **/


           //迭代器 生成器

           /**
                1.迭代

                从一个数据集合中按照一定的顺序,不断取出数据的过程

                2.迭代 和遍历的区别

                迭代强调的是依次取数据 并不保证取多少,也不保证把所有数据取完

                遍历强调的是吧所有数据依次全部取出来

                迭代器

                对迭代过程的封装,在不同语言中有不同的表现形式,通常为对象

                4.迭代模式

                一种设计模式,用于统一迭代过程,并规范了迭代器规格:

                迭代器应该具有得到下一个数据的能力
                迭代器应该具有判断是否还有后续数据的能力

                js规定,如果一个对象具有next 方法,并且该方法返回一个对象,该对象的格式如下

                {value:值,done:是否迭代完成}
                则认为该对象是迭代器

                含义:
                next()  用于得到下一个数据
                返回的对象
                    value:下一个数据的值,
                    done:是否迭代完成
                

                可迭代协议

                es6规定,如果一个对象具有知名符号 Symbol.iterator ,并且属性值是一个迭代器创建函数,则该对象是可迭代的(iterable) 

                dom伪数组 数组 也是可迭代对象

                可使用 for of 循环迭代


                可迭代对象就可以 用展开运算符



                生成器

                generator
                是通过构造函数 Generator 创建的对象,生成器既是一个迭代器,同时又是一个可迭代对象  


                生成器的创建 必须使用生成器函数 (Generator Function)

                function *name(){

                }
                在function 关键字  后面加上 * 或者 函数名前面 则该函数为生成器函数,一定会返回一个可迭代对象

                    生成器内部是为了给生成器的每次迭代提供数据

                    每次调用next方法,将导致 函数运行到下一个 yield

                    yield是一个关键字,该关键字只能在生成器中使用,表达产生一个迭代数据

                    1.生成器函数可以有返回值,返回值出现在第一次done为true时的value属性中

                    2.调用构造器函数的next 时可以传入参数 ,传递的参数会交给yield表达式的返回值

                    3.第一次调用next方法 传参没有意义

                    4.在生成器函数内部可以调用其他生成器函数 
                        function* test(){
                            yield* t();
                        }
                        function* t(){
                            yield 1
                        }

                    生成器的其他api

                    return 方法:调用该方法可以提前结束 迭代器函数,从而让整个函数结束

                    throw方法: 可以在生成器中产生一个错误


                    set  集合

                    set 用于存放不重复的数据 会自动出去重复数据

                    1.如何创建set集合

                    new Set() //建立一个空的set

                    new Set(iterable) //创建一个具有初始内容的set 集合,内容来自于可迭代对象的每一次迭代结果

                    2,如何对set集合进行后续操作

                    add(数据):添加一个数据到set集合的末尾,如果数据已存在,则不进行操作
                        set 使用Object.is的方式判断两个数据是否相等,但是针对+0 和 -0 set认为是相等的
                    has(数据):判断set中是否存在对应的数据
                    delete(数据):删除匹配的数据,返回是否删除成功
                    clear():清空整个set集合

                    3.如何与数据相互转换
                        const s = new Set([1,2,3]);
                        const arr = [...s];

                    4. 如何遍历

                        1.使用for of循环
                        2.使用set的实例方法 forEach((val,val,s))
                        set集合中不存在下标,所以set 的forEach中的回调函数 中的第一个值和第二个值都是一样的第三个值表示,set集合本身


                set应用

                两个数组的  并集,交集,差集 
           **/


    </script>
    <script src="./myPromise.js"></script>
    <script>

    </script>
    <script>
        const pro = new MyPromise((resolve,reject)=>{

        })
    
    </script>
    <script>
        const arr= [1,2,3,4]
        const iterator = {
            i:0 ,//当前数组下标
            next(){
                const res = {
                    value:arr[this.i],
                    done: this.i >= arr.length  
                }
                this.i++;
                return res;
            }
        }

        // 1 1 2 3 5 8
        function feibo(n){
            if(n === 1){
                return
            }else{
                return feibo(n) + feibo(n - 1)
            }
        }

        function* task(){
            const resp = yield  fetch('http://49.232.171.71:8888/sadikjawiodjawiud?u=ashduawhd')
            const result = yield resp.json();
            console.log(result)
        }


        const arr1 = [11,22,33,44,55,66]
        const arr2 = [55,22,33,88,99,00]
        //并集
        const h= [...new Set([...arr1,...arr2])];
        console.log(h)

        //run(task)
        function run(generatorFunc){
            const generator = generatorFunc()
            let result = generator.next(); //启动任务
            handleResult();
            function handleResult(){
                if(result.done){
                    return; //迭代完成
                }
                if(typeof result.value.then === 'function'){
                    //迭代数据是一个promise
                    result.value.then(res=>{
                        reuslt = generator.next(res);
                        handleResult()
                    })
                }else{  
                     //迭代的数据是其他数据进行下一次迭代
                  reuslt = generator.next(result.value);
                  handleResult( )
                }
            }
        }
    </script>
    
</body>
</html>