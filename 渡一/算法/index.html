<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <script src="./linked.js"></script> -->
    <script src="./tree.js"></script>
    <script>
        /* 牛客网


        数据结构与算法

        可以容纳数据的结构被称为数据结构  静态的

        算法是用来对数据结构进行处理的方法 动态的



        线性数据结构

        数组

        线性数据结构 强调存储与顺序

        数组定长

        数组特性:
        1.存储在物理空间上是连续的
        2.底层长度是不可变的
        3.数组的变量,指向了数组第一个元素的位置 arr[] 方括号表示存储地址的偏移 通过偏移查询数据 性能最好
        优点:
        1.查询性能好 指定查询某个位置
        
        缺点:
        1.因为空间必须连续,所以如果数组比较大,容易存不下,当系统的空间碎片较多的时候
        2.因为数组的长度是固定的,所以数组的内容难以被添加和删除 


        链表
        单链表

        想要传递一个链表,必须传递链表的根节点
        每一个节点,都认为自己是根节点

        特性:
        1.在空间上不是连续的
        2.每存放一个值都要开销一个引用空间
        
        优点: 
        1.只要内存大就可以寸的下,不用担心空间碎片的问题
        2.链表的添加和删除很容易

        缺点:
        1.查询速度慢 (查询某个位置)
        2.链表每一个节点都需要创建一个指向next的引用,浪费一些空间
        当节点内数据越多的时候,这部分多开销的内存影响越少


        链表的定义
            function node(){

            }


        线性数据结构的遍历

        遍历:将一个集合中的每一个元素进行获取查看 

        递归 while 

        链表的逆置

冒泡排序
快速排序
选择排序

堆栈

栈：先入后出
队列： 先入先出

双向链表 
class Node(value){
    constructor(value){
        this.value = value;
        
    }
     next=null;
     pre = null;

}

双向链表的优点，无论给出哪一个节点，都能对整个链表进行遍历
双向链表的缺点，多耗费一个引用空间，而且构建时比较负责
         */
     /**
      * 
      * 二维数据结构
    
        二维数组

        二维拓扑结构（图）  

        class node{
            constructor(value){
                this.value = value
                this.neighbor=[]
            }
        }


树形结构 -- 有向无环图 
根节点
叶子节点：下面没有其他节点
 节点：既不是根节点，又不是叶子节点的普通节点

 树的度：这棵树最多有多少个差这个度就为多少
 
 树的深度，树最深有几层，树的深度就为几
是图的一种

        树形结构 有一个根节点

        树形结构没有回路



        二叉树

        树的度最多为2 的树形结构

        满二叉树：
        1.所有的叶子节点都在最底层
        2.每个非叶子节点都有两个子节点


        完全二叉树：
        国内定义：
        1.叶子节点都在最后一层，或倒数第二一层
        2.叶子节点都向左聚拢

        国际定义：
        1.叶子节点都在最后一层，或倒数第二层
        2.如果有叶子节点，就必然有两个叶子节点

        在二叉树中，每个节点都认为自己是根节点
        子树：二叉树中，每一个节点或叶子节点都是一颗子树的根节点

        左子树，右子树



        二叉树的遍历

        传递二叉树要传递根节点

        前序遍历（先根次序遍历 先打印当前，再打印左边的子树，再右边的子树
        中序遍历（中跟次序遍历 先打印左边的子树，再当前，再右边的子树
        后续遍历（后根次序遍历 先打印左边的子树 再右边的子树 再当前


        根据前序中序还原 二叉树  


        二叉树的搜索

        深度优先 ：更适合探索未知  对于二叉树来说，深度优先搜索和前序遍历的顺序一一
        广度优先 ：更适合探索局域 



        二叉树的比较

        左右互换算不算 同一颗树


        最小生成树

        普利姆算法（加点法
            1.任选一个点作为七点
            2.找到一当前选中点为起点路径最短的边
            3.如果这个边的另一端没有被连通起来，那么就连接
            4.如果这个边的另一端被连起来了 则看倒数第二短的边
            5.重复2-4直到将所有点联通
        克鲁斯卡尔算法 （加边法
            1.选择最短的边进行连接
            2.要保证边连接的两端至少有一个点是新的点
            3.或者这个边是将两个部落进行连接
            4.重复1-3直到所有点都连接在一起


            表示一个图 可以用点集合 和边集合



            二叉搜索树

            二叉树  有排序效果，左子树的节点都比当前节点小，右子树的节点都比当前节点大


            平衡二叉树

             1.根节点的左子树与右子树的高度差不能超过1
             2.这颗树的每个子树都符合第一条



            二叉树的单旋操作（左单旋 右单旋

            某一节点不平衡
            如果左边浅，右边深，进行左单旋 

            旋转节点： 不平衡的节点为旋转节点
            新根：旋转之后成为根节点的节点
            变化分支：父节点发生变化的那个分支
            不变分支：父级节点不变的那个分支


            左单旋时：
                旋转节点：当前不平衡的节点
                新根：右子树的根节点
                变化分支：旋转节点的右子树的左子树
                不变分支：旋转节点的右子树的右子树

            右单旋时：
                  旋转节点：当前不平衡的节点
                  新根：左子树的根节点
                  变化分支：旋转节点的左子树的右子树
                  不变分支：旋转节点的左子树的左子树


            进行左单旋：
            1.找到新根
            2.找到变化分支
            3.当前旋转节点的右子树为变化分支 
            4.让新根的做选自为旋转节点
            5.返回新的节点
      * 
      * */  
    </script>
</body>
</html>